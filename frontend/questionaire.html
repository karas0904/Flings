<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Amourette - Profile Details</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@0,6..96,400..900;1,6..96,400..900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
      body {
        background-color: white;
        color: black;
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        position: relative;
        min-height: 100%; /* Ensure body takes full height for scrolling */
        overflow: hidden; /* Prevent scrolling issues with moving shapes */
      }

      .header {
        display: flex;
        justify-content: left;
        padding: 10px 0px 10px 40px;
        background-color: black;
        width: 100%;
        z-index: 10; /* Ensure header stays above glass and shapes */
      }

      .header h1 {
        font-size: 24px;
        padding: 0px 0px 0px 20px;
        color: white;
        margin: 0;
        font-family: "Bodoni Moda", serif;
        font-optical-sizing: auto;
        font-weight: 100;
        font-style: normal;
      }

      .container {
        width: 90%;
        max-width: 800px;
        display: flex;
        justify-content: center;
        align-items: center; /* Center content vertically */
        flex-grow: 1; /* Allow container to grow and push footer */
        position: relative;
        z-index: 5; /* Ensure container is above shapes but below header */
      }

      /* Glass-like transparent background */
      .glass-background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1); /* Slightly transparent white */
        backdrop-filter: blur(10px); /* Blur effect for glassmorphism */
        -webkit-backdrop-filter: blur(10px); /* For Safari compatibility */
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
        z-index: 1; /* Ensure glass is above shapes but below content */
      }

      /* Background container for moving shapes */
      .shapes-background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0; /* Ensure shapes are behind glass */
        overflow: hidden;
      }

      /* Irregular shape 1 (top-right, sky blue) */
      .shape1 {
        position: absolute;
        width: 600px; /* Increased size */
        height: 600px; /* Increased size */
        top: -100px; /* Position in top-right */
        right: -100px;
        background: radial-gradient(
          circle,
          rgba(135, 206, 235, 0.5),
          rgba(135, 206, 235, 0.1)
        ); /* Sky blue with depth */
        clip-path: polygon(
          40% 10%,
          70% 5%,
          90% 20%,
          95% 40%,
          85% 60%,
          70% 80%,
          50% 95%,
          30% 90%,
          20% 70%,
          15% 50%,
          20% 30%,
          30% 15%
        ); /* Amoeba-like shape */
        filter: blur(20px); /* Blur the shape */
        animation: moveShape1 10s infinite ease-in-out;
      }

      /* Irregular shape 2 (bottom-left, rose pink) */
      .shape2 {
        position: absolute;
        width: 600px; /* Increased size */
        height: 600px; /* Increased size */
        bottom: -100px; /* Position in bottom-left */
        left: -100px;
        background: radial-gradient(
          circle,
          rgba(255, 182, 193, 0.5),
          rgba(255, 182, 193, 0.1)
        ); /* Rose pink with depth */
        clip-path: polygon(
          30% 20%,
          50% 10%,
          70% 20%,
          85% 35%,
          90% 50%,
          80% 70%,
          60% 90%,
          40% 95%,
          20% 85%,
          10% 70%,
          5% 50%,
          15% 30%
        ); /* Amoeba-like shape */
        filter: blur(20px); /* Blur the shape */
        animation: moveShape2 12s infinite ease-in-out;
      }

      /* Animation for shape 1 */
      @keyframes moveShape1 {
        0% {
          transform: translate(0, 0) scale(1);
        }
        25% {
          transform: translate(50px, 30px) scale(1.1);
        }
        50% {
          transform: translate(20px, 60px) scale(0.9);
        }
        75% {
          transform: translate(-30px, 20px) scale(1.05);
        }
        100% {
          transform: translate(0, 0) scale(1);
        }
      }

      /* Animation for shape 2 */
      @keyframes moveShape2 {
        0% {
          transform: translate(0, 0) scale(1);
        }
        25% {
          transform: translate(-50px, -30px) scale(1.1);
        }
        50% {
          transform: translate(-20px, -60px) scale(0.9);
        }
        75% {
          transform: translate(30px, -20px) scale(1.05);
        }
        100% {
          transform: translate(0, 0) scale(1);
        }
      }

      /* Content wrapper to hold text and box */
      .content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        z-index: 6; /* Ensure content is above glass and shapes */
      }

      /* Text above the box */
      .content-wrapper h2 {
        font-family: "Bodoni Moda", serif;
        font-size: 28px;
        font-weight: 400;
        color: #333; /* Dark gray for contrast */
        margin: 0 0 20px 0; /* Space between text and box */
        line-height: 1.2;
      }

      /* Centered box with increased height */
      .content-box {
        position: relative;
        width: 100%; /* Adjust width as needed */
        max-width: 500px; /* Limit max width */
        height: 400px; /* Increased height */
        background: rgba(
          245,
          245,
          245,
          0.8
        ); /* Off-white with slight transparency */
        border-radius: 15px; /* Rounded corners */
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Ensure content stays within box */
      }

      /* Top section (1 part) */
      .top-section {
        flex: 1; /* 1 part of the 1:4 ratio */
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(
          255,
          255,
          255,
          0.5
        ); /* Slightly whiter for distinction */
        border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* Subtle divider */
      }

      .top-section p {
        font-family: "Oswald", sans-serif;
        font-size: 20px;
        font-weight: 400;
        color: #555; /* Medium gray for contrast */
        margin: 0;
      }

      /* Bottom section (4 parts) */
      .bottom-section {
        flex: 4; /* 4 parts of the 1:4 ratio */
        display: flex;
        flex-direction: row;
        position: relative;
      }

      /* Columns in bottom section */
      .column {
        flex: 1; /* Equal width for both columns */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer; /* Indicate clickable area */
        position: relative;
        background: rgba(245, 245, 245, 0.8); /* Match box background */
        transition: transform 0.5s ease, opacity 0.5s ease; /* Smooth slide and fade */
      }

      .column p {
        font-family: "Oswald", sans-serif;
        font-size: 18px;
        font-weight: 400;
        color: #555; /* Medium gray for contrast */
        margin: 0;
        z-index: 2; /* Ensure text is above any effects */
      }

      /* Slide animations for left and right columns */
      .column.slide-left {
        transform: translateX(-100%); /* Slide left out of view */
        opacity: 0; /* Fade out */
        background-color: rgba(183, 183, 183, 0.285);
        transition: 1s;
      }

      .column.slide-right {
        transform: translateX(100%); /* Slide right out of view */
        opacity: 0; /* Fade out */
        background-color: rgba(183, 183, 183, 0.285);
        transition: 1s;
      }

      /* Reset animation for smoothness */
      .column:not(.slide-left):not(.slide-right) {
        transform: translateX(0); /* Reset to original position */
        opacity: 1; /* Fully visible */
      }

      /* Skip button styling */
      .skip-button {
        margin-top: 20px; /* Space between the box and the button */
        padding: 5px 30px; /* Vertical and horizontal padding for size */
        background: rgba(215, 208, 208, 0.45); /* Transparent background */
        border: 0px solid rgba(215, 208, 208, 0.45); /* 2px border with dark gray color */
        border-radius: 50px; /* Slightly rounded corners */
        box-shadow: 0 5px 10px 2px rgba(0, 0, 0, 0.2); /* Inward shadow */
        font-family: "Oswald", sans-serif; /* Consistent font */
        font-size: 16px; /* Font size */
        color: #333; /* Text color to match border */
        cursor: pointer; /* Indicate clickable */
        transition: all 0.3s ease; /* Smooth transition for hover effects */
        z-index: 6; /* Ensure button is above glass and shapes */
      }

      /* Hover effect for skip button */
      .skip-button:hover {
        background: rgba(
          255,
          255,
          255,
          0.2
        ); /* Slight white background on hover */
        box-shadow: 5px 1px 10px 2px rgba(0, 0, 0, 0.2); /* Inward shadow */
        color: #000; /* Darken text color on hover */
      }

      /* Container for buttons to center them side by side */
      .button-container {
        display: flex;
        justify-content: center;
        gap: 20px; /* Space between buttons */
        margin-top: 20px; /* Space between the box and buttons */
      }

      /* Let's Match button styling */
      .match-button {
        margin-top: 20px;
        padding: 5px 30px; /* Vertical and horizontal padding for size */
        background: transparent; /* Transparent background */
        border: 0px solid rgba(215, 208, 208, 0.45); /* 2px border with dark gray color */
        border-radius: 50px; /* Slightly rounded corners */
        box-shadow: 0 5px 10px 2px rgba(0, 0, 0, 0.2); /* Inward shadow */
        font-family: "Oswald", sans-serif; /* Consistent font */
        font-size: 16px; /* Font size */
        color: #333; /* Text color to match border */
        cursor: pointer; /* Indicate clickable */
        transition: all 0.3s ease; /* Smooth transition for hover effects */
        z-index: 6; /* Ensure button is above glass and shapes */
      }

      /* Hover effect for Let's Match button */
      .match-button:hover {
        background: rgba(
          255,
          255,
          255,
          0.2
        ); /* Slight white background on hover */
        box-shadow: 5px 1px 10px 2px rgba(0, 0, 0, 0.2); /* Inward shadow */
        color: #000; /* Darken text color on hover */
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Amourette</h1>
    </div>
    <div class="shapes-background">
      <div class="shape1"></div>
      <div class="shape2"></div>
    </div>
    <div class="glass-background"></div>
    <div class="container">
      <div class="content-wrapper">
        <h2>Let your future know you better</h2>
        <div class="content-box">
          <div class="top-section">
            <p id="question-text">Are you a?</p>
          </div>
          <div class="bottom-section">
            <div class="column" id="option1-column">
              <p id="option1-text">Beach</p>
            </div>
            <div class="column" id="option2-column">
              <p id="option2-text">Mountain</p>
            </div>
          </div>
        </div>
        <button class="skip-button">Skip</button>
        <button class="match-button" style="display: none">Let's Match</button>
      </div>
    </div>

    <script type="module">
      import { AutoTokenizer } from "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.4.0";

      let userSelections = [];
      const questions = [
        {
          question: "Are you a?",
          options: ["Beach", "Mountain"],
          type: "trait",
        },
        {
          question: "Do you prefer?",
          options: ["Sunrise", "Sunset"],
          type: "pref",
        },
        {
          question: "Are you more of a?",
          options: ["City", "Countryside"],
          type: "trait",
        },
        {
          question: "Weekend plan?",
          options: ["College", "Chilling"],
          type: "pref",
        },
        {
          question: "You prefer?",
          options: ["Binge-watching", "Gaming"],
          type: "pref",
        },
        {
          question: "Your cravings?",
          options: ["Fast", "Home-cooked"],
          type: "pref",
        },
        {
          question: "Are you an?",
          options: ["Introvert", "Extrovert"],
          type: "trait",
        },
        {
          question: "First message?",
          options: ["Funny", "Deep"],
          type: "pref",
        },
        {
          question: "Do you prefer?",
          options: ["Random", "Well-planned"],
          type: "pref",
        },
        {
          question: "Do you prefer?",
          options: ["Texting", "Calling"],
          type: "pref",
        },
        {
          question: "Ideal first date?",
          options: ["Coffee", "Home"],
          type: "pref",
        },
        {
          question: "Are you a?",
          options: ["Morning", "Night"],
          type: "trait",
        },
        {
          question: "Are you a?",
          options: ["Foody", "Non-foody"],
          type: "trait",
        },
        { question: "Are you?", options: ["Picky", "Easy"], type: "trait" },
        { question: "Do you prefer?", options: ["Music", "No"], type: "pref" },
      ];
      let currentQuestionIndex = 0;

      async function loadModel() {
        try {
          const model = await tf.loadGraphModel("/gpt2-medium-tfjs/model.json");
          console.log("GPT-2 Medium model loaded successfully!");
          return model;
        } catch (error) {
          console.error("Error loading model:", error);
        }
      }

      async function loadTokenizer() {
        try {
          console.log("Starting to load tokenizer...");
          const tokenizer = await AutoTokenizer.from_pretrained("gpt2-medium");
          console.log("Tokenizer loaded successfully!");
          console.log(
            "Tokenizer methods:",
            Object.getOwnPropertyNames(Object.getPrototypeOf(tokenizer))
          );
          const testTokens = await tokenizer.tokenize("beach");
          console.log("Tokenizer test - beach tokens:", testTokens);
          return tokenizer;
        } catch (error) {
          console.error("Error loading tokenizer:", error);
        }
      }

      async function generateText(model, tokenizer, prompt, selections) {
        let inputTensor = null;
        let attentionTensor = null;
        try {
          console.log("Starting text generation with prompt:", prompt);

          let inputIds = await tokenizer.encode(prompt);
          inputIds = inputIds
            .filter((id) => Number.isFinite(id))
            .map((id) => Number(id));
          const attentionMask = Array(inputIds.length).fill(1);
          console.log("Input IDs:", inputIds);
          console.log("Decoded prompt check:", tokenizer.decode(inputIds));

          inputTensor = tf.tensor2d([inputIds], [1, inputIds.length], "int32");
          attentionTensor = tf.tensor2d(
            [attentionMask],
            [1, attentionMask.length],
            "int32"
          );

          let generatedIds = [...inputIds];
          let generatedAttention = [...attentionMask];
          const eosToken = tokenizer.eos_token_id || 50256;
          const maxTokensPerSentence = 15; // More room for traits
          const numSentences = 3;
          let sentences = [];
          const usedSeedIds = new Set();

          const seedTokens = {};
          for (let selection of selections) {
            if (!selection || selection === "empty") continue;
            const tokenIds = await tokenizer.encode(selection.toLowerCase());
            console.log(`Encoded ${selection}:`, tokenIds);
            const validToken = tokenIds[0];
            seedTokens[selection] = validToken;
          }
          const seedKeys = Object.keys(seedTokens);
          console.log("Seed Tokens:", seedTokens);

          if (seedKeys.length < 3) {
            throw new Error("Not enough valid seed tokens for 3 sentences!");
          }

          const shuffledSeeds = [...seedKeys].sort(() => Math.random() - 0.5);
          const selectedSeeds = shuffledSeeds.slice(0, 3);
          console.log("Selected Seeds for Sentences:", selectedSeeds);

          const seedIds = Object.values(seedTokens);

          for (let s = 0; s < numSentences; s++) {
            let seedWord = selectedSeeds[s];
            let currentSeedId = seedTokens[seedWord];
            let sentenceIds = [currentSeedId];
            usedSeedIds.add(currentSeedId);
            generatedIds = [...inputIds, ...sentenceIds];
            generatedAttention = [...attentionMask, 1];

            if (inputTensor) inputTensor.dispose();
            if (attentionTensor) attentionTensor.dispose();
            inputTensor = tf.tensor2d(
              [generatedIds],
              [1, generatedIds.length],
              "int32"
            );
            attentionTensor = tf.tensor2d(
              [generatedAttention],
              [1, generatedAttention.length],
              "int32"
            );

            for (
              let i = 0;
              i < maxTokensPerSentence - 1 &&
              generatedIds[generatedIds.length - 1] !== eosToken;
              i++
            ) {
              const inputs = {
                input_ids: inputTensor,
                attention_mask: attentionTensor,
              };
              const output = model.execute(inputs);

              const logitsTensor = output[2];
              const lastTokenLogits = logitsTensor.slice(
                [0, logitsTensor.shape[1] - 1, 0],
                [1, 1, 50257]
              );

              const k = 15;
              const temperature = 0.9;
              const scaledLogits = lastTokenLogits.div(temperature);
              const topK = scaledLogits.squeeze().topk(k);
              const topIndices = topK.indices.dataSync();

              let nextToken;
              if (Math.random() < 0.4 && sentenceIds.length < 3) {
                // Upped seed bias
                let nextTokenCandidates = topIndices.filter(
                  (id) => seedIds.includes(id) && !usedSeedIds.has(id)
                );
                nextToken =
                  nextTokenCandidates.length > 0
                    ? nextTokenCandidates[
                        Math.floor(Math.random() * nextTokenCandidates.length)
                      ]
                    : topIndices[Math.floor(Math.random() * k)];
              } else {
                nextToken = topIndices[Math.floor(Math.random() * k)];
              }
              nextToken =
                Number.isFinite(nextToken) &&
                nextToken > 200 &&
                nextToken !== eosToken
                  ? Number(nextToken)
                  : topIndices[0];
              console.log(
                `Sentence ${s}, Iteration ${i}: Next Token:`,
                nextToken
              );

              sentenceIds.push(nextToken);
              if (seedIds.includes(nextToken)) usedSeedIds.add(nextToken);
              generatedIds.push(nextToken);
              generatedAttention.push(1);

              if (inputTensor) inputTensor.dispose();
              if (attentionTensor) attentionTensor.dispose();
              inputTensor = tf.tensor2d(
                [generatedIds],
                [1, generatedIds.length],
                "int32"
              );
              attentionTensor = tf.tensor2d(
                [generatedAttention],
                [1, generatedAttention.length],
                "int32"
              );

              if (
                i === maxTokensPerSentence - 2 &&
                ![13, 25, 0].includes(nextToken)
              ) {
                sentenceIds.push(13);
                generatedIds.push(13);
                generatedAttention.push(1);
                break;
              }

              output.forEach((tensor) => tensor.dispose());
            }

            console.log(`Sentence ${s} IDs before decode:`, sentenceIds);
            let decodeIds = sentenceIds.filter(
              (id) => Number.isFinite(id) && id !== eosToken
            );
            if (decodeIds.length === 0) {
              sentences.push("Wild energy short-circuited!");
              console.log(`Sentence ${s} rejected: No valid IDs`);
              continue;
            }
            let sentence = await tokenizer.decode(decodeIds);
            sentence = sentence.trim();

            const commaCount = (sentence.match(/,/g) || []).length;
            const wordCount = sentence.split(" ").length;
            if (commaCount > 2 || !sentence.includes(" ") || wordCount < 4) {
              console.log(
                `Sentence ${s} rejected - Reason: Commas: ${commaCount}, Words: ${wordCount}, Text:`,
                sentence
              );
              sentences.push(`Wild ${seedWord} energy flows!`);
              generatedIds = [...inputIds]; // Reset to prompt
              generatedAttention = [...attentionMask];
            } else {
              if (!sentence.endsWith(".") && !sentence.endsWith("!"))
                sentence += "!";
              sentences.push(sentence);
              generatedIds = [...inputIds, ...sentenceIds]; // Carry forward
              generatedAttention = [
                ...attentionMask,
                ...Array(sentenceIds.length).fill(1),
              ];
            }
          }

          const generatedText = sentences.join("\n");
          console.log("Generated Text:", generatedText);
          return generatedText;
        } catch (error) {
          console.error("Error generating text:", error);
          throw error;
        } finally {
          if (inputTensor) inputTensor.dispose();
          if (attentionTensor) attentionTensor.dispose();
          tf.disposeVariables();
        }
      }

      let gpt2Model;
      let gpt2Tokenizer;

      async function initialize() {
        try {
          console.log("Initializing model and tokenizer...");
          await new Promise((resolve) => setTimeout(resolve, 100));
          gpt2Model = await loadModel();
          gpt2Tokenizer = await loadTokenizer();
        } catch (error) {
          console.error("Initialization error:", error);
        }
      }
      initialize();

      function updateQuestion() {
        const currentQuestion = questions[currentQuestionIndex];
        document.getElementById("question-text").textContent =
          currentQuestion.question;
        document.getElementById("option1-text").textContent =
          currentQuestion.options[0];
        document.getElementById("option2-text").textContent =
          currentQuestion.options[1];
      }

      function handleColumnClick(column, isLeft) {
        const slideClass = isLeft ? "slide-left" : "slide-right";
        try {
          const selectedOption = isLeft
            ? document.getElementById("option1-text").textContent
            : document.getElementById("option2-text").textContent;

          userSelections[currentQuestionIndex] = selectedOption;

          column.classList.add(slideClass);
          setTimeout(() => {
            column.classList.remove(slideClass);
            if (currentQuestionIndex < questions.length - 1) {
              currentQuestionIndex++;
              updateQuestion();
            } else {
              document.querySelector(".skip-button").style.display = "none";
              document.querySelector(".match-button").style.display =
                "inline-block";
              console.log("Final User Selections:", userSelections);
            }
          }, 500);
        } catch (error) {
          console.error("Column click error:", error);
        }
      }

      document
        .getElementById("option1-column")
        .addEventListener("click", function () {
          handleColumnClick(this, true);
        });

      document
        .getElementById("option2-column")
        .addEventListener("click", function () {
          handleColumnClick(this, false);
        });

      document
        .querySelector(".skip-button")
        .addEventListener("click", function () {
          try {
            userSelections[currentQuestionIndex] = "empty";
            if (currentQuestionIndex < questions.length - 1) {
              currentQuestionIndex++;
              updateQuestion();
            } else {
              document.querySelector(".skip-button").style.display = "none";
              document.querySelector(".match-button").style.display =
                "inline-block";
              console.log("Final User Selections:", userSelections);
            }
          } catch (error) {
            console.error("Skip button error:", error);
          }
        });

      document
        .querySelector(".match-button")
        .addEventListener("click", async function () {
          try {
            console.log(
              "Let's Match button clicked! Redirecting to explore.html..."
            );
            window.location.href = "explore.html";
          } catch (error) {
            console.error("Match button error:", error);
          }
        });
    </script>
  </body>
</html>
